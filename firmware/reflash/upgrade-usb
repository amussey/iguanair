#!/usr/bin/python -tt
import warnings
import traceback
import sys
import os
import iguanaIR
import time

#output "constants"
FATAL  = 0
ERROR  = 1
WARN   = 2
ALWAYS = 2.5
NORMAL = 3
INFO   = 4
DEBUG  = 5

msgPrefixes = [
    "FATAL: ",
    "ERROR: ",
    "WARNING: ",
    "",
    "INFO: ",
    "DEBUG: "
]

#local variables
currentLevel = NORMAL
logFile = None
inputFile = None
UNSAFE=False

def dieCleanly(level = None):
    """Exit the application with proper cleanup."""

    #TODO: perform application cleanup

    if level == None:
        level = ERROR

    #exit with appropriate value
    if level == FATAL:
        sys.exit(1)
    sys.exit(0)


def message(level, msg):
    """Print a message to a certain debug level"""
    retval = None

    if level <= currentLevel or level == ALWAYS:
        out = sys.stdout

        # if logfile is open print to it instead
        if logFile == "-":
            out = sys.log
        elif level <= WARN:
            out = sys.stderr

        retval = msgPrefixes[int(level + 0.5)] + msg
        out.write(retval)
        retval = len(retval)

    if level <= FATAL:
        dieCleanly(level)

    return retval


def printUsage(msg = None):
    usage = "Usage: " + sys.argv[0] + """ [OPTION]... <FILE>

-h
--help : Print this usage message.

-l
--log-file : Specify a log to receive all messages.

-q
--quiet : Decrease verbosity.

-v
--verbose : Increase verbosity.
"""

    if msg != None:
        message(FATAL, msg + usage)
    message(ALWAYS, usage)
    dieCleanly(ALWAYS)


index = 1
while index < len(sys.argv):
    arg = sys.argv[index]
    if arg == "--do-not-be-stupid":
        UNSAFE=True
    elif arg == "-h" or arg == "--help":
        printUsage()
    elif arg == "-l" or arg == "--log-file":
        index += 1
        logFile = sys.argv[index]
        if logFile == "-":
            logFile = None
    elif arg == "-q" or arg == "--quiet":
        if currentLevel > FATAL:
            currentLevel -= 1
    elif arg == "-v" or arg == "--verbose":
        currentLevel += 1
    elif inputFile == None:
        inputFile = arg
    else:
        printUsage("Unknown argument: " + arg + "\n")
    index += 1

# open the log file if specified
if logFile != None:
    sys.log = open(logFile, "a", 1)
    logFile = "-"

if inputFile is None:
    message(FATAL, "An input file must be specified.\n")

# NOTE: can convert the bootloader'd device into a version 4 device by
# using version4.txt as the source, no delays, and skipping the send
# function.  I would like to make writing faster by rewriting the PROG
# function in the firmware, but rewriting that function involves
# rewriting the executing page, which erases it.  When the processor
# tries to execute the next command it fails miserably.
#input = open('version4.txt', 'r')

# read the boot loader memory map in
#input = open('bootloader.txt', 'r')
input = open(inputFile, 'r')

# array of hashes of pages that actually hold data
pages = []

def appendPage(start, page):
    global pages
    if page:
        for x in page:
            if x != '30':
                pages.append({ 'start' : start,
                               'bytes' : page })
                break

# read pages from the input file into the pages array
lineNum = 0
start = None
page = []
for line in input:
    line = line.strip()

    lineNum += 1
    if line:
        # parse .hex files from the compiler
        if line[0] == ':':
            lead = line[0:3]
            address = int(line[3:7], 16)
            pad = line[7:9]
            body = line[9:-2]
            checksum = line[-2:]

            if address == 0 and lineNum != 1:
                break

            bytes = []
            for x in range(len(body) / 2):
                bytes.append(body[x * 2:x * 2 + 2])
            appendPage(address, bytes[0:64])
            appendPage(address + 64, bytes[64:])

            if pad != '00':
                message(LOG_FATAL, "pad is not 00: %s\n" % pad)
        # parse the output of the read command from the programmer
        else:
            bytes = line.split()
            if len(bytes) != 17:
                message(WARN, "Ignoring line: %s\n" % line)
            else:
                address = int(bytes.pop(0)[:-1], 16)
                if address % 64 == 0:
                    # save any old page
                    appendPage(start, page)

                    # prepare for the next page
                    start = address
                    page = bytes
                else:
                    page.extend(bytes)

# save the last page
if start is not None:
    appendPage(start, page)

message(INFO, 'Found %d pages that contain data.\n' % len(pages))

# compute the iguana 'writeBlock' data for each page
for page in pages:
    page['data'] = chr(page['start'] / 64)
    if UNSAFE:
        page['data'] += chr(0x42) + chr(0) * 2
    else:
        page['data'] += chr(0) * 3
    for byte in page['bytes']:
        page['data'] += chr(int(byte, 16))

# we have to write the pages in reverse to avoid messing up the jump
# table before we're ready, so reverse the page order.
pages.reverse()

conn = iguanaIR.connect('0')

# detect the version before we try to write it
def deviceTransaction(type, data = ''):
    retval = False
    req = iguanaIR.createRequest(type, data)
    if not iguanaIR.writeRequest(req, conn):
        print 'Failed to write packet.'
    else:
        resp = iguanaIR.readResponse(conn, 10000)
        if iguanaIR.responseIsError(resp):
            print 'Error response.'
        elif type == iguanaIR.IG_DEV_GETVERSION:
            data = iguanaIR.removeData(resp)
            retval = ord(data[0]) + (ord(data[1]) << 8)
        else:
            retval = iguanaIR.removeData(resp)
            #retval = True
    return retval

version = deviceTransaction(iguanaIR.IG_DEV_GETVERSION)
if version <= 4 or \
   version >> 8 == 1 or \
   version == 0xFF00:
    message(INFO, "Found device version 0x%x\n" % version)
else:
    message(FATAL,
            "This script will not modify devices of version 0x%x\n" % version)

# TODO: send only pages that do not conflict with the bootloader code.
# The send function was poorly placed, and future revisions must move
# it.

#deviceTransaction(iguanaIR.IG_DEV_GETBUFSIZE2)
#sys.exit()

writeCommand = iguanaIR.IG_DEV_WRITEBLOCK
if version < 256:
    writeCommand = iguanaIR.IG_DEV_WRITEBLOCK_OLD

# write each page out
for page in pages:
    # write a page
    message(INFO, "Writing page %d (0x%x)\n" % (page['start'] / 64,
                                                page['start']))
    if deviceTransaction(writeCommand, page['data']):
        message(INFO, "Success.\n")
    else:
        message(FATAL, "FAILED!!\n")

# reset the device (it may have already)
deviceTransaction(iguanaIR.IG_DEV_RESET)
