#!/usr/bin/python -tt

#**************************************************************************
# * upgrade-usb ***********************************************************
# **************************************************************************
# *
# * TODO: DESCRIBE AND DOCUMENT THIS FILE
# *
# * Copyright (C) 2007, IguanaWorks Incorporated (http://iguanaworks.net)
# * Author: Joseph Dunn <jdunn@iguanaworks.net>
# *
# * Distributed under the GPL version 2.
# * See LICENSE for license details.
# */



import warnings
import traceback
import time
import glob
import sys
import os

import iguanaIR

#output "constants"
LOG_FATAL  = 0
LOG_ERROR  = 1
LOG_WARN   = 2
LOG_ALWAYS = 2.5
LOG_NORMAL = 3
LOG_INFO   = 4
LOG_DEBUG  = 5

msgPrefixes = [
    "FATAL: ",
    "ERROR: ",
    "WARNING: ",
    "",
    "INFO: ",
    "DEBUG: "
]

FlasherVersion = 0xFF00

null = open('/dev/null', 'r+')

#local variables
currentLevel = LOG_NORMAL
logFile = None
printVersion = False
UNSAFE = False
usb_ir = None
loader = None
body = None

def dieCleanly(level = None):
    """Exit the application with proper cleanup."""

    #TODO: perform application cleanup

    if level == None:
        level = LOG_ERROR

    #exit with appropriate value
    if level == LOG_FATAL:
        sys.exit(1)
    sys.exit(0)


def message(level, msg):
    """Print a message to a certain debug level"""
    retval = None

    if level <= currentLevel or level == LOG_ALWAYS:
        out = sys.stdout

        # if logfile is open print to it instead
        if logFile == "-":
            out = sys.log
        elif level <= LOG_WARN:
            out = sys.stderr

        retval = msgPrefixes[int(level + 0.5)] + msg
        out.write(retval)
        retval = len(retval)

    if level <= LOG_FATAL:
        dieCleanly(level)

    return retval


def printUsage(msg = None):
    usage = "Usage: " + sys.argv[0] + " [OPTION]..." + """

-h
--help : Print this usage message.

-l
--log-file : Specify a log to receive all messages.

-q
--quiet : Decrease verbosity.

-v
--verbose : Increase verbosity.
"""

    if msg != None:
        message(LOG_FATAL, msg + usage)
    message(LOG_ALWAYS, usage)
    dieCleanly(LOG_ALWAYS)


index = 1
while index < len(sys.argv):
    arg = sys.argv[index]
    if arg == "--device-version":
        printVersion = True
    elif arg == "-h" or arg == "--help":
        printUsage()
    elif arg == "--loader":
        index += 1
        loader = sys.argv[index]
    elif arg == "--body":
        index += 1
        body = sys.argv[index]
    elif arg == "--old-firmware":
        index += 1
        usb_ir = sys.argv[index]
    elif arg == "-l" or arg == "--log-file":
        index += 1
        logFile = sys.argv[index]
        if logFile == "-":
            logFile = None
    elif arg == "-q" or arg == "--quiet":
        if currentLevel > LOG_FATAL:
            currentLevel -= 1
    elif arg == "-v" or arg == "--verbose":
        currentLevel += 1
    elif arg == "--really-write":
        UNSAFE = True
    else:
        printUsage("Unknown argument: " + arg + "\n")
    index += 1

# open the log file if specified
if logFile != None:
    sys.log = open(logFile, "a", 1)
    logFile = "-"

_conn = None
def connect(timeout = 0):
    global _conn

    # check every quarter second
    sleepTime = 0.25
    timeoutStart = timeout

    start = None
    while timeout > 0:
        # list the possible devices
        devices = os.listdir('/dev/iguanaIR')
        devices.sort()

        # no change, so lets just run on
        if len(devices) == 0:
            pass
        elif start is None:
            start = devices[0]
        elif len(devices) == 1 and \
             start and start != devices[0]:
            break

        # delay and count down the timeout
        time.sleep(sleepTime)
        timeout -= sleepTime

    devices = os.listdir('/dev/iguanaIR')
    if len(devices) != 1:
        message(LOG_ERROR, "This script should only be used with a single device installed.\n")
    message(LOG_DEBUG,
            'Device list after %s seconds: %s\n' % (timeoutStart - timeout,
                                                    devices))
    _conn = iguanaIR.connect(devices[0])

def deviceTransaction(type, data = ''):
    global _conn

    # connect on demand
    if _conn is None:
        connect()

    retval = False
    req = iguanaIR.createRequest(type, data)
    if not iguanaIR.writeRequest(req, _conn):
        print 'Failed to write packet.'
    else:
        resp = iguanaIR.readResponse(_conn, 10000)
        if resp is None:
            message(LOG_ERROR, "No response received.\n")
        elif type == iguanaIR.IG_DEV_GETVERSION:
            if not iguanaIR.responseIsError(resp):
                data = iguanaIR.removeData(resp)
                retval = ord(data[0]) + (ord(data[1]) << 8)
        elif iguanaIR.responseIsError(resp):
            message(LOG_ERROR,
                    'Error response code: 0x%s\n' % iguanaIR.code(resp))
        else:
            retval = iguanaIR.removeData(resp)
    return retval

def deviceVersion(target = None):
    version = None
    while not version:
        version = deviceTransaction(iguanaIR.IG_DEV_GETVERSION)
        if not version:
            message(LOG_WARN,
                    "Please unplug and replug the device before continuing.\n")
            message(LOG_WARN, "  Press any key to continue.\n")
            sys.stdin.readline()
            connect()

    # just print the version of the target device
    if printVersion:
        message(LOG_NORMAL, "Found device version 0x%x\n" % version)
        sys.exit(0)
    else:
        message(LOG_INFO, "Found device version 0x%x\n" % version)

    if target is not None and \
       target != version:
        message(LOG_FATAL, "Incorrect version (%s != %s) found.  Reflashing has failed.\n" % (version, target))

    return version

def appendPage(start, page, pages):
    if page:
        for x in page:
            if x != '30':
                pages.append({ 'start' : start,
                               'bytes' : page })
                break

def readPages(input):
    pages = []

    # read pages from the input file into the pages array
    lineNum = 0
    start = None
    page = []
    for line in input:
        line = line.strip()

        lineNum += 1
        if line:
            # parse .hex files from the compiler
            if line[0] == ':':
                lead = line[0:3]
                address = int(line[3:7], 16)
                pad = line[7:9]
                body = line[9:-2]
                checksum = line[-2:]

                if address == 0 and lineNum != 1:
                    break

                bytes = []
                for x in range(len(body) / 2):
                    bytes.append(body[x * 2:x * 2 + 2])
                appendPage(address, bytes[0:64], pages)
                appendPage(address + 64, bytes[64:], pages)

                if pad != '00':
                    message(LOG_FATAL, "pad is not 00: %s\n" % pad)
            # parse the output of the read command from the programmer
            else:
                bytes = line.split()
                if len(bytes) != 17:
                    message(LOG_WARN, "Ignoring line: %s\n" % line)
                else:
                    address = int(bytes.pop(0)[:-1], 16)
                    if address % 64 == 0:
                        # save any old page
                        appendPage(start, page, pages)

                        # prepare for the next page
                        start = address
                        page = bytes
                    else:
                        page.extend(bytes)

    # save the last page
    if start is not None:
        appendPage(start, page, pages)

    message(LOG_INFO, 'Found %d pages that contain data.\n' % len(pages))

    return pages

def preparePages(pages):
    # compute the iguana 'writeBlock' data for each page
    for page in pages:
        page['data'] = chr(page['start'] / 64)
        if UNSAFE:
            page['data'] += chr(0x42) + chr(0) * 2
        else:
            page['data'] += chr(0) * 3
        for byte in page['bytes']:
            page['data'] += chr(int(byte, 16))

    #############################################################
    # TODO: version 4 and earlier cannot alter page 0 due to a race....???
    #if version <= 4 and pages[0]['start'] == 0:
    #    if inputFile.endswith('reflasher.hex'):
    #        message(LOG_INFO, "Moving page 0 to 0xF80.\n")
    #        pages[0]['start'] = 0xF80
    #############################################################

    # we have to write the pages in reverse to avoid messing up the jump
    # table before we're ready, so reverse the page order.
    pages.reverse()

def writePagesToDevice(pages):
    # need to know the starting version
    version = deviceVersion()

    # write each page out
    count = 0
    for page in pages:
        count += 1
        # write a page
        sys.stdout.write("  Writing page %d (%d/%d)  \r" % (page['start'] / 64,
                                                            count, len(pages)))
        sys.stdout.flush()
        if deviceTransaction(iguanaIR.IG_DEV_WRITEBLOCK, page['data']):
            message(LOG_DEBUG, "Success.\n")
        else:
            message(LOG_FATAL, "FAILED!!\n")

        # if we're in an older device delay and reconnect
        if version <= 4:
            connect(5)

    # reset the device (it may have already)
    if version > 4:
        message(LOG_INFO, "Rebooting the device.\n")
        deviceTransaction(iguanaIR.IG_DEV_RESET)

def writeHexFile(filename):
    # read the firmware memory map in
    pages = readPages(open(filename, 'r'))
    preparePages(pages)
    writePagesToDevice(pages)

def writeReflasher():
    # detect the version before we try to write it
    if deviceVersion() != FlasherVersion:
        # no matter what happens next we need to put the reflasher on first
        sys.stdout.write('Writing reflasher to the device:\n')
        writeHexFile(os.path.join(sys.path[0], 'hex', 'reflasher.hex'))
        deviceVersion(FlasherVersion)

def findLatest(type):
    latest = None
    latestVersion = None
    for hex in glob.glob(os.path.join(sys.path[0], 'hex', '%s-*.hex' % type)):
        version = int(hex.rsplit('-',1)[-1].split('.', 1)[0])
        if latestVersion is None:
            latestVersion = version

        if latest is None or \
           version > latestVersion:
            latest = hex

    return latest

if usb_ir is None:
    if loader is None:
        # find the most recent loader
        loader = findLatest('loader')

    if loader is None:
        usb_ir = findLatest('usb_ir_enclosed')
        if usb_ir is None:
            usb_ir = findLatest('usb_ir')
    elif body is None:
        body = findLatest('body')

writeReflasher()

# put on the usb_ir if that's the final target version
if usb_ir is not None:
    sys.stdout.write('Writing usb_ir to the device:\n')
    writeHexFile(usb_ir)
    deviceVersion(0x0004)

# put on the boot loader and the correct body
else:
    sys.stdout.write('Writing loader to the device:\n')
    writeHexFile(loader)
    version = deviceVersion(0x0100)

    sys.stdout.write('Writing body to the device:\n')
    writeHexFile(body)
    version = deviceVersion(0x0101)
