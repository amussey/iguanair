;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: USB_cls_hid.asm
;;   Version: 1.5, Updated on 2008/6/23 at 12:26:41
;;  Generated by PSoC Designer 5.0.423.0
;;
;;  DESCRIPTION: USB Human Interface Device (HID) Class request implemenatation
;;               for the enCoRe II family of devices
;;
;;  NOTE: User Module APIs conform to the fastcall convention for marshalling
;;        arguments and observe the associated "Registers are volatile" policy.
;;        This means it is the caller's responsibility to preserve any values
;;        in the X and A registers that are still needed after the API
;;        function returns. Even though these registers may be preserved now,
;;        there is no guarantee they will be preserved in future releases.
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2004. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "USB_macros.inc"
include "USB.inc"

;-----------------------------------------------
;  Global Symbols
;-----------------------------------------------
EXPORT USB_UpdateHIDTimer
EXPORT _USB_UpdateHIDTimer
EXPORT USB_bGetProtocol
EXPORT _USB_bGetProtocol

AREA bss (RAM,REL)
;-----------------------------------------------
;  Constant Definitions
;-----------------------------------------------
;-----------------------------------------------
; Variable Allocation
;-----------------------------------------------
;----------------------------------------------------------------------------
; Interface Setting
;----------------------------------------------------------------------------
 USB_IdleReload:                        BLK   1h    ; Idle Timer Reload Value
 USB_IdleTimer:                         BLK   1h    ; Idle Timers
 USB_Protocol:                          BLK   1h    ; Active Protocol

AREA UserModules (ROM, REL)
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_bGetProtocol
;
;  DESCRIPTION:   Returns the selected protocol value to the application
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:    A: Interface number
;
;  RETURNS:      A: Protocol values
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.SECTION
 USB_bGetProtocol:
_USB_bGetProtocol:
    MOV    X, A                        ; Argument is the index
    MOV    A, [X + USB_Protocol] ; Return the protocol
    RET
.ENDSECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_UpdateHIDTimer
;
;  DESCRIPTION:    Updates the HID report timer and reloads it if it expires
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:     A: Interface number
;
;  RETURNS:       A: USB_IDLE_TIMER_EXPIRED, if the timer is running and expired
;                    USB_IDLE_TIMER_RUNNING, if the timer is running
;                    USB_IDLE_TIMER_INDEFINITE, if the report should be made on change
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
.SECTION
 USB_UpdateHIDTimer:
_USB_UpdateHIDTimer:
    MOV    X, A                        ; Make the argument the index
; Flow here to check if the timer is "indefinite"
    CMP    [X + USB_IdleReload], 0     ; Indefinite?
    JZ     .indefinite                 ; Jump if Indefinite?
; Flow here to check the timers
    DEC    [X + USB_IdleTimer]         ; Decrement the timer
    JC     .expired
; Flow here if the timer has not expired
    MOV    A, USB_IDLE_TIMER_RUNNING   ; Return value (not expired)
    RET                                ; Quick exit
; Jump here if the timer expired
.expired:
    MOV    A, [X + USB_IdleReload]     ; Reload the timer
    MOV    [X + USB_IdleTimer], A      ; 
    MOV    A, USB_IDLE_TIMER_EXPIRED   ; Return value (expired)
    RET                                ; Quick exit
; Jump here to make return "on change/indefinite"
.indefinite:
    MOV    A, USB_IDLE_TIMER_INDEFINITE; Return value (change/indefinite)
    RET                                ; Exit
.ENDSECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_std_ifc_06
;
;  DESCRIPTION:   Get Interface Descriptor
;
;****************************************************************
; STANDARD INTERFACE IN REQUEST: Get_Interface_Descriptor
;****************************************************************
;
; bmRequestType   : (IN | STANDARD | INTERFACE)    = 81h
; bRequest        : GET_DESCRIPTOR                 = 06h    
; wValue          : DESCRIPTOR TYPE | INDEX        = xxxxh  
; wIndex          : INTERFACE                      = --xxh
; wLength         : DESCRIPTOR_LENGTH              = --xxh  
; 
; The GET_INTERFACE_DESCRIPTOR request returns the specified 
; descriptor if the descriptor exists. 
;
; The upper byte of request_value contains the descriptor type and 
; the lower byte contains the descriptor index. request_index 
; contains either 0000h or the Language ID. request_length contains 
; the descriptor length. The actual descriptor information is 
; transferred in subsequent data packets. 
;
; USB defines only a DEVICE recipient but the HID spec added 
; support for the INTERFACE recipient.
;
; Get Descriptor from an HID interface returns either HID, 
; REPORT, or PHYSICAL descriptors.
;
;****************************************************************
IF (USB_CB_SRC_d2h_std_ifc_06 & USB_UM_SUPPLIED)
export  USB_CB_d2h_std_ifc_06
USB_CB_d2h_std_ifc_06:
    CALL    USB_GetInterfaceLookupTable  ; Point the the interface lookup table
    PUSH    A                          ; Save the MSB
    MOV     A, REG[USB_EP0DATA+wValueHi] ; Get descriptor type
    CMP     A, DESCR_TYPE_HID_CLASS    ; HID Class descriptor?
    JZ      .send_hid_class_descr
    CMP     A, DESCR_TYPE_HID_REPORT   ; HID Report descriptor?
    JZ      .send_hid_report_descr
; Jump or flow here if the request is not supported
.not_supported:
    POP     A                          ; Restore the stack
    JMP     USB_Not_Supported_Local_Hid
; Jump here to send the HID Report Descriptor
.send_hid_report_descr:
    POP     A                          ; Restore the interface lookup table MSB
    SWAP    A, X                       ; Add the offset
    ADD     A, 2                       ; Point to the right table entry
    JMP     .finish
; Jump here to send the HID Class Descriptor
.send_hid_class_descr:
    POP     A                          ; Restore the interface lookup table MSB
    SWAP    A, X                       ; Add the offset
    ADD     A, 4                       ; Point to the right table entry
; Jump or flow here with A:X Pointing to the 
.finish:
    SWAP    A, X                       ; Back where they belong
    ADC     A, 0                       ; Don't forget the carry
    MOV     [USB_t2],USB_t1            ; Set the GETWORD destination 
    LCALL   USB_GETWORD                ; Get the pointer to the transfer descriptor table
                                       ; ITempW has the address
; Get the interface number
    MOV     A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
    MOV     [USB_t2], A                ; Save it for the call to LOOKUP
    MOV     A, [USB_t1]                ; Get the transfer descriptor ROM Address MSB
    MOV     X, [USB_t1+1]              ; Get the transfer descriptor ROM Address LSB

    JMP     USB_GetTableEntry_Local_Hid
ELSE
IF (USB_CB_SRC_d2h_std_ifc_06 & USB_APP_SUPPLIED)
export  USB_CB_d2h_std_ifc_06
USB_CB_d2h_std_ifc_06:
    LJMP    APP_USB_CB_d2h_std_ifc_06
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_cls_ifc_01
;
;  DESCRIPTION:   Get Report
;
;****************************************************************
; HID CLASS INTERFACE IN REQUEST: Get_Report   
;****************************************************************
;
; bmRequestType  : (IN | CLASS | INTERFACE)       = A1h
; bRequest       : GET_REPORT                     = 01h    
; wValue         : REPORT TYPE | REPORT ID        = xxxxh  
; wIndex         : INTERFACE                      = --xxh
; wLength        : REPORT LENGTH                  = --xxh  
; 
; The GET_REPORT request allows the host to receive a report from 
; a specific interface via the control pipe. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_cls_ifc_01 & USB_UM_SUPPLIED)
export  USB_CB_d2h_cls_ifc_01
USB_CB_d2h_cls_ifc_01:

    CALL    Find_Report
    NULL_PTR_CHECK USB_Not_Supported_Local_Hid
    
    JMP     USB_GetTableEntry_Local_Hid
ELSE
IF (USB_CB_SRC_d2h_cls_ifc_01 & USB_APP_SUPPLIED)
export  USB_CB_d2h_cls_ifc_01
USB_CB_d2h_cls_ifc_01:
    LJMP    APP_USB_CB_d2h_cls_ifc_01
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_cls_ifc_02
;
;  DESCRIPTION:   Get Idle
;
;****************************************************************
; HID CLASS INTERFACE IN REQUEST: Get_Idle
;****************************************************************
;
; bmRequestType  : (OUT | CLASS | INTERFACE)      = A1h
; bRequest       : GET_IDLE                       = 02h    
; wValue         : REPORT ID                      = 00xxh  
; wIndex         : INTERFACE                      = --xxh
; wLength        : Report Size                    = 0001h  
; 
; The GET_IDLE request reads the current idle rate for a given 
; input report on a specific interface. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_cls_ifc_02 & USB_UM_SUPPLIED)
.LITERAL
GetSetIdleTable:
    TD_START_TABLE  1h                 ; One entry for each interface
    TD_ENTRY        USB_DS_RAM, 1, USB_IdleReload,   NULL_PTR  ; Reuse the transfer buffer
    TD_ENTRY        USB_DS_RAM, 1, USB_IdleReload+1, NULL_PTR  ; Reuse the transfer buffer
.ENDLITERAL
export  USB_CB_d2h_cls_ifc_02
USB_CB_d2h_cls_ifc_02:
    MOV     A, REG[USB_EP0DATA+wValueLo] ; Get the report number
    CMP     A, 0                       ; We don't support report by report idle
    JNZ     USB_Not_Supported_Local_Hid

    MOV     A, REG[USB_EP0DATA+wIndexLo] ; Get the interface number
    CMP     A, 1h                      ; We don't support report by report idle
    JNC     USB_Not_Supported_Local_Hid

    MOV     [USB_t2], A                ; Use the UM temp var--Selector
    MOV     A,>GetSetIdleTable         ; Get the ROM Address MSB
    MOV     X,<GetSetIdleTable         ; Get the ROM Address LSB
    
    JMP     USB_GetTableEntry_Local_Hid
ELSE
IF (USB_CB_SRC_d2h_cls_ifc_02 & USB_APP_SUPPLIED)
export  USB_CB_d2h_cls_ifc_02
USB_CB_d2h_cls_ifc_02:
    LJMP    APP_USB_CB_d2h_cls_ifc_02
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_d2h_cls_ifc_03
;
;  DESCRIPTION:   Get Protocol
;
;****************************************************************
; HID CLASS INTERFACE IN REQUEST: Get_Protocol
;****************************************************************
;
; bmRequestType  : (OUT | CLASS | INTERFACE)      = A1h
; bRequest       : GET_PROTOCOL                   = 03h    
; wValue         : RESERVED                       = 0000h  
; wIndex         : INTERFACE                      = --xxh
; wLength        : SIZEOF_INTERFACE_PROTOCOL      = 0001h  
; 
; The GET_PROTOCOL request reads which protocol is currently 
; active.
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_d2h_cls_ifc_03 & USB_UM_SUPPLIED)
.LITERAL
GetProtocolTable:
    TD_START_TABLE  2                  ; One entry for BOOT/One entry for REPORT
    TD_ENTRY        USB_DS_ROM, 1, ROM_ZERO,   NULL_PTR  ; Simply use a a hard coded zero or one
    TD_ENTRY        USB_DS_ROM, 1, ROM_ONE,    NULL_PTR  ; 
ROM_ZERO:   DB  0
ROM_ONE:    DB  1
.ENDLITERAL
export  USB_CB_d2h_cls_ifc_03
USB_CB_d2h_cls_ifc_03:
    MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the interface number
    CMP     A, 1h                      ; Range check
    JNC     USB_Not_Supported_Local_Hid

    MOV     X, A                       ; Get the protocol for the requested interface
    MOV     A, [X + USB_Protocol]      ; 

    MOV     [USB_t2], A                ; Use the UM temp var--Selector

    MOV     A,>GetProtocolTable        ; Get the ROM Address MSB
    MOV     X,<GetProtocolTable        ; Get the ROM Address LSB
    
    JMP     USB_GetTableEntry_Local_Hid
ELSE
IF (USB_CB_SRC_d2h_cls_ifc_03 & USB_APP_SUPPLIED)
export  USB_CB_d2h_cls_ifc_03
USB_CB_d2h_cls_ifc_03:
    LJMP    APP_USB_CB_d2h_cls_ifc_03
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_cls_ifc_09
;
;  DESCRIPTION:   Set Report
;
;****************************************************************
; HID CLASS INTERFACE OUT REQUEST: Set_Report
;****************************************************************
;
; bmRequestType   : (OUT | CLASS | INTERFACE)      = 21h
; bRequest        : SET_REPORT                     = 09h    
; wValue          : REPORT TYPE | REPORT ID        = xxxxh  
; wIndex          : INTERFACE                      = --xxh
; wLength         : REPORT LENGTH                  = --xxh  
; 
; The SET_REPORT request allows the host to send a report to the 
; device, possibly setting the state of input, output or feature 
; controls. 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_cls_ifc_09 & USB_UM_SUPPLIED)
export  USB_CB_h2d_cls_ifc_09
USB_CB_h2d_cls_ifc_09:
    CALL    Find_Report
    NULL_PTR_CHECK USB_Not_Supported_Local_Hid
    
    JMP     USB_GetTableEntry_Local_Hid
ELSE
IF (USB_CB_SRC_h2d_cls_ifc_09 & USB_APP_SUPPLIED)
export  USB_CB_h2d_cls_ifc_09
USB_CB_h2d_cls_ifc_09:
    LJMP    APP_USB_CB_h2d_cls_ifc_09
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_cls_ifc_10
;
;  DESCRIPTION:   Set Idle
;
;****************************************************************
; HID CLASS INTERFACE OUT REQUEST: Set_Idle
;****************************************************************
;
; bmRequestType   : (OUT | CLASS | INTERFACE)      = 21h
; bRequest        : SET_IDLE                       = 0Ah    
; wValue          : DURATION | REPORT ID           = xxxxh  
; wIndex          : INTERFACE                      = --xxh
; wLength         : ZERO                           = 0000h  
; 
; The SET_IDLE request silences a particular input report (or all 
; input reports) on a specific interface until a new event occurs 
; or the specified amount of time passes. 
;
;****************************************************************
; Note: This function does not support multiple reports per interface.
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_cls_ifc_10 & USB_UM_SUPPLIED)
export  USB_CB_h2d_cls_ifc_10
USB_CB_h2d_cls_ifc_10:
    MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the report number
    CMP     A, 0                       ; We don't support report by report idle
    JNZ     USB_Not_Supported_Local_Hid

    MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the interface number
    CMP     A, 1h                      ; Range Check
    JNC     USB_Not_Supported_Local_Hid

    MOV     X, A                       ; Interface Number becomes an index

    MOV     A, REG[USB_EP0DATA+wValueHi]  ; Get the duration

    MOV     [X+USB_IdleReload], A      ; Save the reload immediately
    CMP     A, 0                       ; Is this request setting the duration to indefinite?
    JZ      .reload                    ; If so, reload the timer 

    ; Otherwise, we need to determine if we reset the current expiry
    ; (HID Spec says to send the next report if we are within 4 ms (1 count)
    ; of sending the next report
    CMP     [X+USB_IdleTimer], 1       ; Within 4 ms?
    JZ      .done                      ; Jump to let the timer expire "naturally" 

; Jump or Flow here to reload the timer
.reload:
    MOV     [x+USB_IdleTimer], A       ; Reload the timer
            
.done:
    JMP     USB_NoDataStageControlTransfer
ELSE
IF (USB_CB_SRC_h2d_cls_ifc_10 & USB_APP_SUPPLIED)
export  USB_CB_h2d_cls_ifc_10
USB_CB_h2d_cls_ifc_10:
    LJMP    APP_USB_CB_h2d_cls_ifc_10
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_CB_h2d_cls_ifc_11
;
;  DESCRIPTION:   Set Idle
;
;****************************************************************
; HID CLASS INTERFACE OUT REQUEST: Set_Protocol
;****************************************************************
;
; bmRequestType  : (OUT | CLASS | INTERFACE)      = 21h
; bRequest       : SET_PROTOCOL                   = 0Bh    
; wValue         : DURATION | REPORT ID           = xxxxh  
; wIndex         : PROTOCOL                       = --xxh
; wLength        : ZERO                           = 0000h  
; 
; The SET_PROTOCOL request switches between the boot protocol and 
; the report protocol (or vice versa). 
;
;****************************************************************
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
IF (USB_CB_SRC_h2d_cls_ifc_11 & USB_UM_SUPPLIED)
export  USB_CB_h2d_cls_ifc_11
USB_CB_h2d_cls_ifc_11:
    MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the interface number
    CMP     A, 1h                      ; Range check
    JNC     USB_Not_Supported_Local_Hid

    MOV     X, A                       ; Save the interface number

    MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the protocol
    CMP     A, (1+1)                   ; Must be zero or one
    JNC     USB_Not_Supported_Local_Hid

    MOV     [X + USB_Protocol], A      ; Save the new protocol

    LJMP     USB_NoDataStageControlTransfer
ELSE
IF (USB_CB_SRC_h2d_cls_ifc_11 & USB_APP_SUPPLIED)
export  USB_CB_h2d_cls_ifc_11
USB_CB_h2d_cls_ifc_11:
    LJMP    APP_USB_CB_h2d_cls_ifc_11
ENDIF
ENDIF
;-----------------------------------------------------------------------------
;  FUNCTION NAME:   Find_Report
;
;  DESCRIPTION:     Scan the HID Report Tree and return a pointer to the 
;                   HID Report Transfer Descriptor (TD) or NULL
;                   This function is called in during the processing of
;                   GET_REPORT or SET_REPORT HID Class Requests.
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:       
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
export USB_cls_hid_Find_Report
USB_cls_hid_Find_Report:
Find_Report:
    CALL    USB_GetInterfaceLookupTable  ; Point the the interface lookup table
    ; The first entry of the table point to the report table.
    MOV     [USB_t2],USB_t1            ; Set the GETWORD destination 
    CALL    USB_GETWORD                ; Get the pointer to the transfer descriptor table
                                       ; ITempW has the address
    MOV     A, REG[USB_EP0DATA+wIndexLo]  ; Get the interface number
    MOV     [USB_t2], A                ; Use the UM temp var--Selector
    MOV     A, [USB_t1]                ; Get the Table Address MSB
    MOV     X, [USB_t1+1]              ; Get the Table Address LSB

    ASL     [USB_t2]                   ; Convert the index to offset

    SWAP    A, X
    ADD     A, [USB_t2]
    SWAP    A, X
    ADC     A, 0                       ; A:X now points to the table entry we want

; Get the pointer to the Report Type Table
    GET_WORD

; Dereference to the requested Report Type
    PUSH    A                          ; Don't loose the pointer MSB
    MOV     A, REG[USB_EP0DATA+wValueHi]  ; Get the Report Type
    DEC     A                          ; Make it 0 based
    MOV     [USB_t2], A                ; Use the UM temp var--Selector
    POP     A                          ; Get the MSB back
    PUSH    A                          ; Don't loose the pointer MSB
    ROMX                               ; Get the table size
    CMP     A, [USB_t2]                ; Range check
    JC      .not_supported_pop_1
        
    POP     A                          ; Get the MSB back
    INC     X                          ; Point to the next  entry
    ADC     A, 0                       ;

    LT_INDEX_TO_OFFSET USB_t2          ; Convert the index to offset

    SWAP    A, X
    ADD     A, [USB_t2]
    SWAP    A, X
    ADC     A, 0                       ; A:X now points to the table entry we want
; Get the pointer to the requested Report Table
    GET_WORD                            ; A:X points to the 

    NULL_PTR_CHECK .not_supported      ; Null Table entries indicated not supported
; Dereference to the requested TRANSFER DESCRIPTOR
    PUSH    A                          ; Don't loose the pointer MSB
    MOV     A, REG[USB_EP0DATA+wValueLo]  ; Get the Report ID
    MOV     [USB_t2], A                ; Use the UM temp var--Selector
    POP     A                          ; Get the MSB back
    PUSH    A                          ; Don't loose the pointer MSB
    ROMX                               ; Get the table size
    CMP     A, [USB_t2]                ; Range check
    JC      .not_supported_pop_1
        
    POP     A                          ; Get the MSB back

    RET                                ; Finished A:X point to the TD

.not_supported_pop_1:
    POP     A                          ; Restore the stack
.not_supported:
    MOV     A, 0                       ; Return a null pointer
    MOV     X, A                       ; 
    RET

;-----------------------------------------------------------------------------
;  FUNCTION NAME: USB_GetInterfaceLookupTable
;
;  DESCRIPTION:   Point to the interface lookup table
;
;-----------------------------------------------------------------------------
;
;  ARGUMENTS:
;
;  RETURNS:
;
;  SIDE EFFECTS: REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
;
;  THEORY of OPERATION or PROCEDURE:
;
;-----------------------------------------------------------------------------
export  USB_GetInterfaceLookupTable:
USB_GetInterfaceLookupTable:
    CALL    USB_GET_CONFIG_TABLE_ENTRY ; Get the CONFIG_LOOKUP entry
    SWAP    A, X                       ; Second entry points to the HID_LOOKUP table
    ADD     A, 2                       ; So add two
    SWAP    A, X                       ; 
    ADC     A, 0                       ; Don't forget the carry
    MOV     [USB_t2],USB_t1            ; Set the GETWORD destination 
    CALL    USB_GETWORD                ; Get the pointer to the HID_LOOKUP table
                                       ; ITempW has the address
    MOV     A, [USB_t1]                ; Get the table address MSB
    MOV     X, [USB_t1+1]              ; Get the table address LSB
    RET
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
;  USB 2nd Tier Dispactch Jump Tables for HID Class Requests (based on bRequest)
;-----------------------------------------------------------------------------
;  FUNCTION NAME: ;  USB 2nd Tier Dispactch Jump Table
;
;  DESCRIPTION:   The following tables dispatch to the Standard request handler
;                 functions.  (Assumes bmRequestType(5:6) is 0, Standard)
;
;-----------------------------------------------------------------------------
;-----------------------------------------------------------------------------
USB_DT_h2d_cls_ifc:
;-----------------------------------------------------------------------------
    jmp     USB_CB_h2d_cls_ifc_00
    jmp     USB_CB_h2d_cls_ifc_01
    jmp     USB_CB_h2d_cls_ifc_02
    jmp     USB_CB_h2d_cls_ifc_03
    jmp     USB_CB_h2d_cls_ifc_04
    jmp     USB_CB_h2d_cls_ifc_05
    jmp     USB_CB_h2d_cls_ifc_06
    jmp     USB_CB_h2d_cls_ifc_07
    jmp     USB_CB_h2d_cls_ifc_08
    jmp     USB_CB_h2d_cls_ifc_09
    jmp     USB_CB_h2d_cls_ifc_10
    jmp     USB_CB_h2d_cls_ifc_11
    jmp     USB_CB_h2d_cls_ifc_12

USB_DT_h2d_cls_ifc_End:
USB_DT_h2d_cls_ifc_Size: equ (USB_DT_h2d_cls_ifc_End-USB_DT_h2d_cls_ifc) / 2
USB_DT_h2d_cls_ifc_Dispatch::
    CMP     [USB_Configuration], 0     ; Is the device configured?
    JNZ     .configured                ; Jump on configured
    JMP     USB_Not_Supported_Local_Hid  ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    MOV     A, REG[USB_EP0DATA + bRequest]       ; Get the request number
    DISPATCHER USB_DT_h2d_cls_ifc, USB_DT_h2d_cls_ifc_Size, USB_Not_Supported_Local_Hid 

;-----------------------------------------------------------------------------
USB_DT_d2h_cls_ifc:
;-----------------------------------------------------------------------------

    jmp     USB_CB_d2h_cls_ifc_00
    jmp     USB_CB_d2h_cls_ifc_01
    jmp     USB_CB_d2h_cls_ifc_02
    jmp     USB_CB_d2h_cls_ifc_03

USB_DT_d2h_cls_ifc_End:
USB_DT_d2h_cls_ifc_Size: equ (USB_DT_d2h_cls_ifc_End-USB_DT_d2h_cls_ifc) / 2
USB_DT_d2h_cls_ifc_Dispatch::
    CMP     [USB_Configuration], 0     ; Is the device configured?
    JNZ     .configured                ; Jump on configured
    JMP     USB_Not_Supported_Local_Hid  ; Stall the request if not configured
; Jump here if the device is configured
.configured:
    MOV     A, REG[USB_EP0DATA + bRequest]       ; Get the request number
    DISPATCHER USB_DT_d2h_cls_ifc, USB_DT_d2h_cls_ifc_Size, USB_Not_Supported_Local_Hid 

IF (USB_CB_SRC_d2h_cls_ifc_00 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_cls_ifc_00
USB_CB_d2h_cls_ifc_00:
ENDIF
IF (USB_CB_SRC_d2h_cls_ifc_01 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_cls_ifc_01
USB_CB_d2h_cls_ifc_01:
ENDIF
IF (USB_CB_SRC_d2h_cls_ifc_02 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_cls_ifc_02
USB_CB_d2h_cls_ifc_02:
ENDIF
IF (USB_CB_SRC_d2h_cls_ifc_03 & USB_NOT_SUPPORTED)
export  USB_CB_d2h_cls_ifc_03
USB_CB_d2h_cls_ifc_03:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_00 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_00
USB_CB_h2d_cls_ifc_00:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_01 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_01
USB_CB_h2d_cls_ifc_01:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_02 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_02
USB_CB_h2d_cls_ifc_02:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_03 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_03
USB_CB_h2d_cls_ifc_03:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_04 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_04
USB_CB_h2d_cls_ifc_04:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_05 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_05
USB_CB_h2d_cls_ifc_05:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_06 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_06
USB_CB_h2d_cls_ifc_06:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_07 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_07
USB_CB_h2d_cls_ifc_07:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_08 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_08
USB_CB_h2d_cls_ifc_08:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_09 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_09
USB_CB_h2d_cls_ifc_09:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_10 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_10
USB_CB_h2d_cls_ifc_10:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_11 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_11
USB_CB_h2d_cls_ifc_11:
ENDIF
IF (USB_CB_SRC_h2d_cls_ifc_12 & USB_NOT_SUPPORTED)
export  USB_CB_h2d_cls_ifc_12
USB_CB_h2d_cls_ifc_12:
ENDIF

USB_Not_Supported_Local_Hid:
    LJMP     USB_Not_Supported

USB_GetTableEntry_Local_Hid:
    LJMP     USB_GetTableEntry

;-----------------------------------------------
; Add custom application code for routines 
; redefined by USB_APP_SUPPLIED in USB_HID.INC
;-----------------------------------------------

   ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
   ;---------------------------------------------------
   ; Insert your custom code below this banner
   ;---------------------------------------------------

   ;---------------------------------------------------
   ; Insert your custom code above this banner
   ;---------------------------------------------------
   ;@PSoC_UserCode_END@ (Do not change this line.)

; End of File USB_cls_hid.asm
